"""
Step definitions for Section 1.8: Effects
Reference: Flesh and Blood Comprehensive Rules Section 1.8

This module implements behavioral tests for effect rules:
- Rule 1.8.1: Effects are generated by abilities or other effects
- Rule 1.8.1a: Source of an effect is same as source of generating ability/effect
- Rule 1.8.1b: Controller of an effect is same as controller of generating ability/effect
- Rule 1.8.2: Object whose abilities generate an effect is considered object with that effect
- Rule 1.8.3: Optional effects require player choice; typically contain "may"
- Rule 1.8.3a: Player chooses whether to generate/apply optional effect
- Rule 1.8.3b: Optional effect blocked if cannot be generated; "may choose to" allows choice regardless
- Rule 1.8.4: Conditional effects depend on condition being met
- Rule 1.8.4a: "Otherwise" effect conditional on preceding effect failing
- Rule 1.8.4b: "Unless" effect conditional on opposite condition
- Rule 1.8.4c: "While" effect applies only while condition met; evaluated continuously
- Rule 1.8.5: Targeted effects declare targets as object goes on stack
- Rule 1.8.5a: Only public objects in arena or stack are targetable unless specified
- Rule 1.8.5b: Same target cannot be declared twice for one target phrase
- Rule 1.8.5c: Non-target effects do not require target declaration at stack placement
- Rule 1.8.5d: Targeted effect restricted by what effect can apply to
- Rule 1.8.5e: Optional targeted effect: player may choose no target
- Rule 1.8.5f: Modified target must be legal for original effect
- Rule 1.8.6: Undetermined parameters resolved by instructed player
- Rule 1.8.6a: Multiple players determine parameters clockwise from controller
- Rule 1.8.6b: Parameters must be public objects in arena or stack unless stated
- Rule 1.8.6c: Insufficient objects means all legal objects become parameters
- Rule 1.8.6d: Player determines order of compound events
- Rule 1.8.7: Effect referring to property value infers property existence
- Rule 1.8.7a: Missing numeric property uses zero as value
- Rule 1.8.8: "As though" and "counts as" effects apply only for that applicable effect
- Rule 1.8.9: Effect fails if target ceases to exist, no legal parameters, or all events fail
- Rule 1.8.10: "Your next attack" refers to next attack coming under player's control
- Rule 1.8.10a: Already-controlled object that becomes specified attack type does not get effect

Engine Features Needed for Section 1.8:
- [ ] Effect class with source, controller, and effect type (Rule 1.8.1)
- [ ] Effect.source tracking per generating ability/effect (Rule 1.8.1a)
- [ ] Effect.controller tracking per generating ability/effect controller (Rule 1.8.1b)
- [ ] CardInstance.has_effect(effect_type) method (Rule 1.8.2)
- [ ] OptionalEffect class with player_choice tracking (Rule 1.8.3)
- [ ] OptionalEffect.can_be_generated() validation (Rule 1.8.3b)
- [ ] OptionalEffect.is_may_choose_to phrasing distinction (Rule 1.8.3b)
- [ ] ConditionalEffect class with condition evaluation (Rule 1.8.4)
- [ ] OtherwiseEffect class conditional on preceding failure (Rule 1.8.4a)
- [ ] UnlessEffect class conditional on opposite condition (Rule 1.8.4b)
- [ ] WhileEffect class with continuous condition evaluation per subject (Rule 1.8.4c)
- [ ] TargetedEffect class with target declaration at stack placement (Rule 1.8.5)
- [ ] TargetedEffect.get_legal_targets() filtering public arena/stack objects (Rule 1.8.5a)
- [ ] TargetedEffect.validate_target_declaration() rejecting duplicates (Rule 1.8.5b)
- [ ] TargetedEffect.requires_declaration_at_play = True (Rule 1.8.5)
- [ ] NonTargetedEffect with declaration deferred to resolution (Rule 1.8.5c)
- [ ] TargetedEffect.apply_restrictions() based on effect parameters (Rule 1.8.5d)
- [ ] TargetedEffect.can_choose_no_target for optional targeted effects (Rule 1.8.5e)
- [ ] TargetedEffect.modify_target() validating legal targets (Rule 1.8.5f)
- [ ] ParameterizedEffect.determine_parameters(player_id) (Rule 1.8.6)
- [ ] ParameterizedEffect.determine_parameters_clockwise(controller_id) (Rule 1.8.6a)
- [ ] ParameterizedEffect.get_legal_parameter_objects() public only (Rule 1.8.6b)
- [ ] ParameterizedEffect.use_all_available_if_insufficient (Rule 1.8.6c)
- [ ] CompoundEvent.determine_order(player_id) (Rule 1.8.6d)
- [ ] PropertyExistenceCheck for effect conditions (Rule 1.8.7)
- [ ] Effect.use_zero_for_missing_numeric_property = True (Rule 1.8.7a)
- [ ] AsThoughEffect and CountsAsEffect scoped to applicable effect only (Rule 1.8.8)
- [ ] Effect.fail() when target ceases to exist (Rule 1.8.9)
- [ ] Effect.partial_success when some events fail (Rule 1.8.9)
- [ ] NextAttackEffect tracking "next attack" under player control (Rule 1.8.10)
- [ ] NextAttackEffect.does_not_apply_retroactively for property changes (Rule 1.8.10a)
"""

import pytest
from pytest_bdd import scenario, given, when, then, parsers
from fab_engine.cards.model import CardInstance, CardTemplate, CardType, Color, Subtype
from fab_engine.zones.zone import ZoneType


# ---------------------------------------------------------------------------
# Scenario: effect generated by ability changes game state
# Tests Rule 1.8.1 - Effect generated by ability changes game state
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect generated by ability changes game state",
)
def test_effect_generated_by_ability_changes_game_state():
    """Rule 1.8.1: An effect generated by an ability changes the game state."""
    pass


@given('a player has a card "Chain Lightning" with a damage-dealing ability')
def step_chain_lightning_with_damage_ability(game_state):
    """Rule 1.8.1: Card has an ability that generates a damage effect."""
    game_state.chain_lightning = game_state.create_card(name="Chain Lightning")
    game_state.chain_lightning.functional_text = (
        "If you've played another Wizard non-attack action card this turn, "
        "deal 3 arcane damage to each opposing hero."
    )
    game_state.initial_hero_life = 20
    game_state.target_hero_life = game_state.initial_hero_life


@when("the ability generates a deal damage effect")
def step_ability_generates_damage_effect(game_state):
    """Rule 1.8.1: Effect is generated by the ability."""
    # Engine Feature Needed: Effect system with generate() call
    # The ability generates an effect that should deal damage
    game_state.damage_effect = game_state.create_damage_effect(
        source=game_state.chain_lightning,
        damage_amount=3,
        damage_type="arcane",
    )
    # Simulate applying the effect (deals 3 damage)
    game_state.target_hero_life = game_state.initial_hero_life - 3


@then("the effect should change the game state by dealing damage")
def step_effect_changes_game_state(game_state):
    """Rule 1.8.1: Effect changes game state by dealing damage."""
    # Engine Feature Needed: Effect.apply() modifying hero life total
    assert game_state.target_hero_life < game_state.initial_hero_life
    assert game_state.damage_effect is not None


# ---------------------------------------------------------------------------
# Scenario: effect source is same as generating ability source
# Tests Rule 1.8.1a - Effect source inherits from generating ability
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect source is same as generating ability source",
)
def test_effect_source_same_as_ability_source():
    """Rule 1.8.1a: The source of an effect equals the source of the generating ability."""
    pass


@given('a player has a card "Electrify" with a delayed triggered damage effect')
def step_electrify_with_delayed_effect(game_state):
    """Rule 1.8.1a: Electrify creates a delayed triggered effect."""
    game_state.electrify = game_state.create_card(name="Electrify")
    game_state.electrify.functional_text = (
        "The next time an attack action card hits a hero this turn, "
        "it deals 3 damage to them."
    )
    game_state.attack_card = game_state.create_card(name="Surging Strike")


@given("the effect specifies the attack action card as its source")
def step_effect_specifies_attack_source(game_state):
    """Rule 1.8.1a: Effect explicitly specifies a different source."""
    game_state.specified_source = game_state.attack_card


@when("the effect triggers and generates a damage effect")
def step_effect_triggers_damage(game_state):
    """Rule 1.8.1a: Delayed effect triggers and generates damage effect."""
    # Engine Feature Needed: DelayedTriggeredEffect system
    game_state.triggered_damage_effect = game_state.create_damage_effect(
        source=game_state.specified_source,  # Attack card is the source
        damage_amount=3,
        damage_type="normal",
    )


@then("the damage effect source should be the attack action card")
def step_damage_source_is_attack_card(game_state):
    """Rule 1.8.1a: Effect source is the specified attack action card."""
    # Engine Feature Needed: Effect.source attribute tracking source card
    assert game_state.triggered_damage_effect.source is game_state.attack_card


# ---------------------------------------------------------------------------
# Scenario: effect controller is same as generating ability controller
# Tests Rule 1.8.1b - Effect controller inherits from generating ability
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect controller is same as generating ability controller",
)
def test_effect_controller_same_as_ability_controller():
    """Rule 1.8.1b: The controller of an effect equals the controller of the generating ability."""
    pass


@given("player 0 controls a card with an ability")
def step_player_0_controls_card_with_ability(game_state):
    """Rule 1.8.1b: Player 0 is the controller."""
    game_state.ability_card = game_state.create_card(name="Ability Card", owner_id=0)
    game_state.ability_card.controller_id = 0


@when("player 0's ability generates an effect")
def step_player_0_ability_generates_effect(game_state):
    """Rule 1.8.1b: Effect is generated by player 0's ability."""
    # Engine Feature Needed: Effect generated from ability, inheriting controller
    game_state.generated_effect = game_state.create_damage_effect(
        source=game_state.ability_card,
        controller_id=0,
        damage_amount=2,
    )


@then("the effect controller should be player 0")
def step_effect_controller_is_player_0(game_state):
    """Rule 1.8.1b: Effect controller is player 0."""
    # Engine Feature Needed: Effect.controller_id attribute
    assert game_state.generated_effect.controller_id == 0


# ---------------------------------------------------------------------------
# Scenario: effect can specify a different controller
# Tests Rule 1.8.1b - Effect can override controller
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect can specify a different controller",
)
def test_effect_can_specify_different_controller():
    """Rule 1.8.1b: Effect can specify a different controller than generating ability controller."""
    pass


@given(
    "player 0 controls a card with an ability that specifies player 1 as effect controller"
)
def step_player_0_card_with_player1_controller_effect(game_state):
    """Rule 1.8.1b: Ability specifies player 1 as effect controller."""
    game_state.control_card = game_state.create_card(name="Control Card", owner_id=0)
    game_state.control_card.controller_id = 0
    game_state.specified_effect_controller = 1  # Player 1 is specified


@when("the ability generates an effect")
def step_ability_generates_effect_with_override(game_state):
    """Rule 1.8.1b: Effect is generated with controller override."""
    # Engine Feature Needed: Effect with explicit controller_id override
    game_state.override_effect = game_state.create_damage_effect(
        source=game_state.control_card,
        controller_id=game_state.specified_effect_controller,  # Override to player 1
        damage_amount=1,
    )


@then("the effect controller should be player 1")
def step_effect_controller_is_player_1(game_state):
    """Rule 1.8.1b: Effect controller is player 1 (overridden)."""
    # Engine Feature Needed: Effect.controller_id attribute with override support
    assert game_state.override_effect.controller_id == 1


# ---------------------------------------------------------------------------
# Scenario: card with conditional damage effect is considered to have that effect
# Tests Rule 1.8.2 - Object considered to have effect its abilities generate
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "card with conditional damage effect is considered to have that effect",
)
def test_card_with_conditional_effect_considered_to_have_effect():
    """Rule 1.8.2: Object with ability generating conditional effect is considered to have that effect."""
    pass


@given(
    'a card "Chain Lightning" whose ability conditionally generates a deal 3 arcane damage effect'
)
def step_chain_lightning_conditional_effect(game_state):
    """Rule 1.8.2: Chain Lightning has a conditional deal-damage ability."""
    game_state.chain_lightning_card = game_state.create_card(name="Chain Lightning")
    game_state.chain_lightning_card.functional_text = (
        "If you've played another Wizard non-attack action card this turn, "
        "deal 3 arcane damage to each opposing hero."
    )
    # Mark as having an arcane damage effect (engine would parse this from functional_text)
    game_state.chain_lightning_card._has_deal_damage_effect = True
    game_state.chain_lightning_card._damage_type = "arcane"


@when("checking if Chain Lightning is a card with a deal damage effect")
def step_check_chain_lightning_has_deal_damage_effect(game_state):
    """Rule 1.8.2: Check if Chain Lightning is considered to have deal-damage effect."""
    # Engine Feature Needed: CardInstance.has_effect("deal_damage") method
    game_state.has_damage_effect = game_state.check_card_has_effect(
        game_state.chain_lightning_card, "deal_damage"
    )


@then("it should be considered a card with an effect that deals arcane damage")
def step_chain_lightning_considered_to_have_damage_effect(game_state):
    """Rule 1.8.2: Chain Lightning is considered a card with deal-arcane-damage effect."""
    # Engine Feature Needed: CardInstance.has_effect() returning True for conditional effects
    assert game_state.has_damage_effect is True


@then("the card is considered an object with the effect even though it is conditional")
def step_card_has_effect_even_though_conditional(game_state):
    """Rule 1.8.2: Conditional effects still count for "is considered" checks."""
    # The conditional nature doesn't change the card's classification
    assert game_state.chain_lightning_card.functional_text is not None
    # Engine Feature Needed: CardInstance.has_effect() including conditional effects


# ---------------------------------------------------------------------------
# Scenario: card with optional damage effect is considered to have that effect
# Tests Rule 1.8.2 - Including optional effects
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "card with optional damage effect is considered to have that effect",
)
def test_card_with_optional_effect_considered_to_have_effect():
    """Rule 1.8.2: Object with optional effect-generating ability is considered to have that effect."""
    pass


@given('a card with an optional effect "may deal 2 damage"')
def step_card_with_optional_damage_effect(game_state):
    """Rule 1.8.2: Card has an optional deal-damage ability."""
    game_state.optional_damage_card = game_state.create_card(
        name="Optional Damage Card"
    )
    game_state.optional_damage_card.functional_text = (
        "You may deal 2 damage to target hero."
    )
    game_state.optional_damage_card._has_deal_damage_effect = True


@when("checking if the card has a deal damage effect")
def step_check_optional_damage_card_effect(game_state):
    """Rule 1.8.2: Check if optional damage card is considered to have deal-damage effect."""
    # Engine Feature Needed: CardInstance.has_effect() including optional effects
    game_state.has_optional_damage_effect = game_state.check_card_has_effect(
        game_state.optional_damage_card, "deal_damage"
    )


@then("it should be considered a card with a deal damage effect")
def step_optional_card_has_damage_effect(game_state):
    """Rule 1.8.2: Optional effect still counts as having that effect."""
    # Engine Feature Needed: CardInstance.has_effect() returning True for optional effects
    assert game_state.has_optional_damage_effect is True


# ---------------------------------------------------------------------------
# Scenario: optional effect requires player choice to generate
# Tests Rule 1.8.3 - Optional effect requires player choice
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "optional effect requires player choice to generate",
)
def test_optional_effect_requires_player_choice():
    """Rule 1.8.3: An optional effect requires the player to choose to generate it."""
    pass


@given('a player has a card with an optional effect "you may banish 3 cards"')
def step_card_with_may_banish_effect(game_state):
    """Rule 1.8.3: Card has an optional banish effect."""
    game_state.may_banish_card = game_state.create_card(name="Banish Card")
    game_state.may_banish_card.functional_text = "You may banish 3 cards."
    # Put 3+ eligible cards in hand
    for i in range(3):
        card = game_state.create_card(name=f"Card {i}")
        game_state.player.hand.add_card(card)


@given("the player has 3 or more eligible cards")
def step_player_has_eligible_cards(game_state):
    """Rule 1.8.3: Player has enough cards to banish."""
    assert len(game_state.player.hand.cards) >= 3


@when("the optional effect would be generated")
def step_optional_effect_would_be_generated(game_state):
    """Rule 1.8.3: Optional effect is ready to be generated."""
    # Engine Feature Needed: OptionalEffect.prompt_player() requiring choice
    game_state.optional_effect = game_state.create_optional_effect(
        source=game_state.may_banish_card,
        effect_text="banish 3 cards",
        can_be_generated=True,
    )


@then("the player must choose whether to generate the effect")
def step_player_must_choose(game_state):
    """Rule 1.8.3: Optional effects require explicit player choice."""
    # Engine Feature Needed: OptionalEffect.requires_player_choice = True
    assert game_state.optional_effect.requires_player_choice is True


# ---------------------------------------------------------------------------
# Scenario: player can choose not to generate optional effect
# Tests Rule 1.8.3a - Player chooses whether to generate optional effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "player can choose not to generate optional effect",
)
def test_player_can_decline_optional_effect():
    """Rule 1.8.3a: Player can choose not to generate an optional effect."""
    pass


@given('a player has a card with an optional effect "you may banish a card"')
def step_card_with_may_banish_one_effect(game_state):
    """Rule 1.8.3a: Card has optional banish effect."""
    game_state.may_banish_card = game_state.create_card(name="Banish Card")
    game_state.may_banish_card.functional_text = "You may banish a card."
    card = game_state.create_card(name="Target Card")
    game_state.player.hand.add_card(card)


@given("the player decides not to generate the optional effect")
def step_player_decides_not_to_generate(game_state):
    """Rule 1.8.3a: Player explicitly declines the optional effect."""
    game_state.player_chose_to_generate = False


@when("the optional effect choice is evaluated")
def step_optional_effect_is_evaluated(game_state):
    """Rule 1.8.3a: Effect is evaluated after player's choice."""
    game_state.optional_effect_result = game_state.resolve_optional_effect(
        source=game_state.may_banish_card,
        player_choice=game_state.player_chose_to_generate,
    )


@then("the optional effect should not be generated")
def step_effect_not_generated(game_state):
    """Rule 1.8.3a: Effect is not generated when player declines."""
    # Engine Feature Needed: OptionalEffect.generate() returning None when declined
    assert game_state.optional_effect_result.was_generated is False


# ---------------------------------------------------------------------------
# Scenario: optional effect cannot be generated when conditions are unmet
# Tests Rule 1.8.3b - Optional effect blocked when conditions unmet
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "optional effect cannot be generated when conditions are unmet",
)
def test_optional_effect_blocked_when_conditions_unmet():
    """Rule 1.8.3b: Optional effect cannot be generated if conditions cannot be met."""
    pass


@given('a player has a card "Murky Water" with an optional effect to banish 3 traps')
def step_murky_water_optional_banish_traps(game_state):
    """Rule 1.8.3b: Murky Water has optional banish 3 traps effect."""
    game_state.murky_water = game_state.create_card(name="Murky Water")
    game_state.murky_water.functional_text = (
        "… you may banish face-down 3 traps from your graveyard."
    )


@given("the player has fewer than 3 traps in their graveyard")
def step_fewer_than_3_traps(game_state):
    """Rule 1.8.3b: Conditions unmet - not enough traps."""
    game_state.trap_count_in_graveyard = 2  # Only 2 traps, need 3
    game_state.required_trap_count = 3


@when("checking if the optional effect can be generated")
def step_check_if_optional_effect_can_be_generated(game_state):
    """Rule 1.8.3b: Check if effect can be generated given current state."""
    # Engine Feature Needed: OptionalEffect.can_be_generated() checking game state
    game_state.can_generate = game_state.check_optional_effect_can_be_generated(
        source=game_state.murky_water,
        required_objects_count=game_state.required_trap_count,
        available_objects_count=game_state.trap_count_in_graveyard,
    )


@then("the player cannot choose to generate the optional effect")
def step_player_cannot_choose_optional_effect(game_state):
    """Rule 1.8.3b: Effect cannot be generated when conditions aren't met."""
    # Engine Feature Needed: OptionalEffect.can_be_generated() returning False
    assert game_state.can_generate is False


# ---------------------------------------------------------------------------
# Scenario: may choose to phrasing allows choice even when effect may fail
# Tests Rule 1.8.3b - "May choose to" phrasing allows choice regardless of outcome
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "may choose to phrasing allows choice even when effect may fail",
)
def test_may_choose_to_phrasing_allows_choice_regardless():
    """Rule 1.8.3b: 'May choose to' phrasing allows choice even if effect cannot fully resolve."""
    pass


@given(
    'a player has a card "Mark of the Huntsman" with a "may choose to" optional effect'
)
def step_mark_of_huntsman_with_may_choose_to_effect(game_state):
    """Rule 1.8.3b: Mark of the Huntsman uses 'may choose to' phrasing."""
    game_state.mark_of_huntsman = game_state.create_card(name="Mark of the Huntsman")
    game_state.mark_of_huntsman.functional_text = (
        "When this hits a hero, you may choose to destroy this and mark them."
    )
    game_state.mark_of_huntsman._is_may_choose_to_phrasing = True


@given("the optional effect may not fully resolve")
def step_optional_effect_may_not_fully_resolve(game_state):
    """Rule 1.8.3b: The card can't be destroyed or hero already marked."""
    game_state.card_can_be_destroyed = False
    game_state.hero_is_already_marked = True


@when("checking if the player can choose to generate the effect")
def step_check_may_choose_to_generate(game_state):
    """Rule 1.8.3b: Check if may-choose-to phrasing allows choice."""
    # Engine Feature Needed: OptionalEffect.is_may_choose_to and permitting choice regardless
    game_state.can_choose_may_choose_to = game_state.check_may_choose_to_effect(
        source=game_state.mark_of_huntsman,
        is_may_choose_to_phrasing=game_state.mark_of_huntsman._is_may_choose_to_phrasing,
        can_fully_resolve=False,
    )


@then("the player may choose to generate the effect regardless of outcome")
def step_player_may_choose_regardless_of_outcome(game_state):
    """Rule 1.8.3b: May-choose-to phrasing allows choice regardless of outcome."""
    # Engine Feature Needed: OptionalEffect with is_may_choose_to = True allowing choice
    assert game_state.can_choose_may_choose_to is True


# ---------------------------------------------------------------------------
# Scenario: conditional effect is not generated when condition is not met
# Tests Rule 1.8.4 - Conditional effect not generated when condition unmet
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "conditional effect is not generated when condition is not met",
)
def test_conditional_effect_not_generated_when_condition_unmet():
    """Rule 1.8.4: A conditional effect is not generated when its condition is not met."""
    pass


@given(
    'a card "Chain Lightning" has a conditional effect "If you\'ve played another Wizard non-attack action card this turn, deal 3 arcane damage"'
)
def step_chain_lightning_conditional_setup(game_state):
    """Rule 1.8.4: Chain Lightning has a conditional deal-damage ability."""
    game_state.chain_lightning_cond = game_state.create_card(name="Chain Lightning")
    game_state.wizard_cards_played_this_turn = 0


@given("the player has not played another Wizard non-attack action card this turn")
def step_no_wizard_card_played(game_state):
    """Rule 1.8.4: Condition is not met - no Wizard cards played."""
    game_state.wizard_cards_played_this_turn = 0


@when("the chain lightning card resolves without condition met")
def step_chain_lightning_resolves(game_state):
    """Rule 1.8.4: Chain Lightning resolves - check if condition is met."""
    condition_met = game_state.wizard_cards_played_this_turn >= 1
    game_state.damage_effect_generated = condition_met


@then("the conditional damage effect should not be generated")
def step_deal_damage_not_generated(game_state):
    """Rule 1.8.4: Damage effect not generated when condition not met."""
    # Engine Feature Needed: ConditionalEffect.evaluate_condition() returning False
    assert game_state.damage_effect_generated is False


# ---------------------------------------------------------------------------
# Scenario: conditional effect is generated when condition is met
# Tests Rule 1.8.4 - Conditional effect generated when condition met
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "conditional effect is generated when condition is met",
)
def test_conditional_effect_generated_when_condition_met():
    """Rule 1.8.4: A conditional effect is generated when its condition is met."""
    pass


@given(
    'a card has a conditional effect "If you\'ve played another Wizard non-attack action card this turn, deal 3 arcane damage"'
)
def step_conditional_effect_with_condition(game_state):
    """Rule 1.8.4: Card has conditional damage ability."""
    game_state.conditional_card = game_state.create_card(name="Chain Lightning")
    game_state.wizard_cards_played_this_turn_met = 0


@given("the player has played another Wizard non-attack action card this turn")
def step_wizard_card_was_played(game_state):
    """Rule 1.8.4: Condition is met - a Wizard card was played."""
    game_state.wizard_cards_played_this_turn_met = 1


@when("the chain lightning card resolves with condition met")
def step_card_resolves_condition_met(game_state):
    """Rule 1.8.4: Card resolves with condition met."""
    condition_met = game_state.wizard_cards_played_this_turn_met >= 1
    game_state.arcane_damage_effect_generated = condition_met


@then("the deal 3 arcane damage effect should be generated")
def step_arcane_damage_effect_generated(game_state):
    """Rule 1.8.4: Arcane damage effect generated when condition met."""
    # Engine Feature Needed: ConditionalEffect.evaluate_condition() returning True, generating effect
    assert game_state.arcane_damage_effect_generated is True


# ---------------------------------------------------------------------------
# Scenario: otherwise effect triggers when preceding effect condition not met
# Tests Rule 1.8.4a - "Otherwise" conditional effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "otherwise effect triggers when preceding effect condition not met",
)
def test_otherwise_effect_triggers_when_preceding_fails():
    """Rule 1.8.4a: Otherwise effect triggers when the preceding effect's condition is not met."""
    pass


@given(
    'a card "Runeblood Incantation" has effects "If you do, create a Runechant token. Otherwise, destroy Runeblood Incantation"'
)
def step_runeblood_incantation_otherwise_effects(game_state):
    """Rule 1.8.4a: Runeblood Incantation has otherwise effect."""
    game_state.runeblood = game_state.create_card(name="Runeblood Incantation")
    game_state.runeblood._has_otherwise_effect = True


@given("the player cannot remove a verse counter from Runeblood Incantation")
def step_cannot_remove_verse_counter(game_state):
    """Rule 1.8.4a: Preceding effect (remove counter) fails."""
    game_state.verse_counters = 0  # No verse counters
    game_state.can_remove_verse_counter = False


@when("the card effect is evaluated")
def step_runeblood_effect_evaluated(game_state):
    """Rule 1.8.4a: Effect is evaluated; preceding effect fails."""
    # Engine Feature Needed: OtherwiseEffect evaluated when preceding fails
    preceding_succeeded = game_state.can_remove_verse_counter
    game_state.create_token_effect_generated = preceding_succeeded
    game_state.destroy_self_effect_generated = not preceding_succeeded


@then('the "Otherwise" effect should be generated')
def step_otherwise_effect_generated(game_state):
    """Rule 1.8.4a: Otherwise effect is generated because preceding failed."""
    # Engine Feature Needed: OtherwiseEffect.generate() called when preceding fails
    assert game_state.destroy_self_effect_generated is True


@then('the "create Runechant token" effect should not be generated')
def step_create_token_not_generated(game_state):
    """Rule 1.8.4a: Primary effect not generated when condition failed."""
    assert game_state.create_token_effect_generated is False


# ---------------------------------------------------------------------------
# Scenario: otherwise effect does not trigger when preceding effect succeeds
# Tests Rule 1.8.4a - "Otherwise" effect does not trigger when preceding succeeds
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "otherwise effect does not trigger when preceding effect succeeds",
)
def test_otherwise_effect_not_triggered_when_preceding_succeeds():
    """Rule 1.8.4a: Otherwise effect does not trigger when preceding effect succeeds."""
    pass


@given('a card has effects "If you do, create a token. Otherwise, destroy this card"')
def step_card_with_otherwise_effect(game_state):
    """Rule 1.8.4a: Card has otherwise effect."""
    game_state.otherwise_card = game_state.create_card(name="Otherwise Card")
    game_state.otherwise_card._has_otherwise_effect = True


@given("the preceding effect succeeds")
def step_preceding_effect_succeeds(game_state):
    """Rule 1.8.4a: Preceding effect succeeds."""
    game_state.preceding_effect_succeeded = True


@when("the otherwise conditional effect is evaluated")
def step_otherwise_effect_evaluated_success(game_state):
    """Rule 1.8.4a: Effect evaluated after preceding succeeds."""
    # Otherwise effect only triggers if preceding fails
    game_state.otherwise_effect_generated = not game_state.preceding_effect_succeeded


@then("the otherwise effect should not be generated")
def step_otherwise_not_generated(game_state):
    """Rule 1.8.4a: Otherwise effect not generated when preceding succeeds."""
    # Engine Feature Needed: OtherwiseEffect.generate() returning None when preceding succeeds
    assert game_state.otherwise_effect_generated is False


# ---------------------------------------------------------------------------
# Scenario: unless effect triggers when opposite condition not met
# Tests Rule 1.8.4b - "Unless" conditional effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "unless effect triggers when opposite condition not met",
)
def test_unless_effect_triggers_when_opposite_not_met():
    """Rule 1.8.4b: Unless effect triggers when the opposite condition is not met."""
    pass


@given(
    'a card "Pitfall Trap" has an effect "deal 2 damage to the attacking hero unless they pay 1 resource"'
)
def step_pitfall_trap_unless_effect(game_state):
    """Rule 1.8.4b: Pitfall Trap has unless effect."""
    game_state.pitfall_trap = game_state.create_card(name="Pitfall Trap")
    game_state.pitfall_trap.functional_text = (
        "… deal 2 damage to the attacking hero unless they pay {r}."
    )


@given("the attacking hero does not pay the resource cost")
def step_attacking_hero_does_not_pay(game_state):
    """Rule 1.8.4b: Opposite condition (paying) is not met."""
    game_state.attacking_hero_paid = False


@when("the pitfall trap unless effect is evaluated")
def step_pitfall_effect_evaluated(game_state):
    """Rule 1.8.4b: Unless effect evaluated."""
    # Engine Feature Needed: UnlessEffect.evaluate() checking opposite condition
    opposite_condition_met = game_state.attacking_hero_paid
    game_state.deal_2_damage_generated = not opposite_condition_met


@then("the deal 2 damage effect should be generated")
def step_deal_2_damage_generated(game_state):
    """Rule 1.8.4b: Damage is dealt when unless condition not met."""
    # Engine Feature Needed: UnlessEffect generating damage when OPPCONDITION not met
    assert game_state.deal_2_damage_generated is True


# ---------------------------------------------------------------------------
# Scenario: unless effect does not trigger when opposite condition is met
# Tests Rule 1.8.4b - "Unless" effect does not trigger when condition met
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "unless effect does not trigger when opposite condition is met",
)
def test_unless_effect_not_triggered_when_condition_met():
    """Rule 1.8.4b: Unless effect does not trigger when the opposite condition is met."""
    pass


@given('a card has an effect "deal 2 damage unless they pay 1 resource"')
def step_card_with_unless_effect(game_state):
    """Rule 1.8.4b: Card has unless effect."""
    game_state.unless_card = game_state.create_card(name="Unless Card")
    game_state.unless_card.functional_text = "Deal 2 damage unless they pay 1 resource."


@given("the defending player pays the resource cost")
def step_defending_player_pays(game_state):
    """Rule 1.8.4b: Opposite condition is met (paid)."""
    game_state.defending_player_paid = True


@when("the unless effect with payment is evaluated")
def step_unless_effect_evaluated_paid(game_state):
    """Rule 1.8.4b: Unless effect evaluated when cost paid."""
    opposite_condition_met = game_state.defending_player_paid
    game_state.deal_damage_generated_unless = not opposite_condition_met


@then("the deal damage effect should not be generated")
def step_unless_damage_not_generated(game_state):
    """Rule 1.8.4b: Damage not dealt when unless condition met."""
    # Engine Feature Needed: UnlessEffect not generating when OPPCONDITION is met
    assert game_state.deal_damage_generated_unless is False


# ---------------------------------------------------------------------------
# Scenario: while effect applies only while condition is met
# Tests Rule 1.8.4c - "While" effect applies only while condition met
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "while effect applies only while condition is met",
)
def test_while_effect_applies_while_condition_met():
    """Rule 1.8.4c: While effect applies only while the condition is met."""
    pass


@given(
    'a card "Parable of Humility" has an effect "attack action cards get -1 power while attacking and defending"'
)
def step_parable_of_humility_while_effect(game_state):
    """Rule 1.8.4c: Parable of Humility has a while conditional effect."""
    game_state.parable_of_humility = game_state.create_card(name="Parable of Humility")
    game_state.parable_of_humility.functional_text = "Attack action cards your opponents control get -1{p} while attacking and defending."


@given("an attack action card is currently attacking")
def step_attack_card_currently_attacking(game_state):
    """Rule 1.8.4c: Condition is met - card is attacking."""
    game_state.attack_card_while = game_state.create_card(name="Attack Card")
    game_state.attack_card_while._is_attacking = True
    game_state.attack_card_while._is_defending = False


@when("checking whether the while effect applies to the attacking card")
def step_check_while_effect_applies(game_state):
    """Rule 1.8.4c: Evaluate if while condition is met for this subject."""
    # Engine Feature Needed: WhileEffect.evaluate_condition_for_subject(card)
    condition_met = (
        game_state.attack_card_while._is_attacking
        or game_state.attack_card_while._is_defending
    )
    game_state.while_effect_applies = condition_met


@then("the effect should apply to the attacking card")
def step_while_effect_applies(game_state):
    """Rule 1.8.4c: While effect applies when condition is met."""
    # Engine Feature Needed: WhileEffect applied when condition is True
    assert game_state.while_effect_applies is True


# ---------------------------------------------------------------------------
# Scenario: while condition evaluated separately for each subject
# Tests Rule 1.8.4c - "While" condition evaluated per subject
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "while condition evaluated separately for each subject",
)
def test_while_condition_evaluated_per_subject():
    """Rule 1.8.4c: While condition is evaluated separately for each subject."""
    pass


@given('a card has an effect "objects get a bonus while condition is true"')
def step_card_with_per_subject_while_effect(game_state):
    """Rule 1.8.4c: Card has while effect evaluated per subject."""
    game_state.per_subject_card = game_state.create_card(name="Per Subject Card")


@given("the effect applies to two objects")
def step_two_objects_affected(game_state):
    """Rule 1.8.4c: Two subjects for the effect."""
    game_state.object_a = game_state.create_card(name="Object A")
    game_state.object_b = game_state.create_card(name="Object B")


@given("the condition is true for object A but false for object B")
def step_condition_true_for_a_false_for_b(game_state):
    """Rule 1.8.4c: Different condition per subject."""
    game_state.object_a._while_condition_met = True
    game_state.object_b._while_condition_met = False


@when("evaluating whether the while effect applies")
def step_evaluate_while_per_subject(game_state):
    """Rule 1.8.4c: Evaluate condition per subject."""
    # Engine Feature Needed: WhileEffect.evaluate_per_subject() checking per-object conditions
    game_state.while_applies_to_a = game_state.object_a._while_condition_met
    game_state.while_applies_to_b = game_state.object_b._while_condition_met


@then("the effect should apply to object A")
def step_while_applies_to_object_a(game_state):
    """Rule 1.8.4c: Effect applies to A because its condition is met."""
    # Engine Feature Needed: WhileEffect per-subject evaluation
    assert game_state.while_applies_to_a is True


@then("the effect should not apply to object B")
def step_while_does_not_apply_to_object_b(game_state):
    """Rule 1.8.4c: Effect does not apply to B because its condition is not met."""
    # Engine Feature Needed: WhileEffect per-subject evaluation
    assert game_state.while_applies_to_b is False


# ---------------------------------------------------------------------------
# Scenario: targeted effect requires target declaration when placed on stack
# Tests Rule 1.8.5 - Targeted effect requires target declaration
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "targeted effect requires target declaration when placed on stack",
)
def test_targeted_effect_requires_declaration_at_stack():
    """Rule 1.8.5: Targeted effects require target declaration when put on stack."""
    pass


@given('a player has a card with a targeted effect "deal 3 damage to target hero"')
def step_card_with_targeted_damage_effect(game_state):
    """Rule 1.8.5: Card has a targeted damage effect."""
    game_state.targeted_damage_card = game_state.create_card(name="Frosting")
    game_state.targeted_damage_card.functional_text = (
        "Deal 3 arcane damage to any target."
    )
    game_state.targeted_damage_card._has_targeted_effect = True


@when("the targeted card is placed onto the stack")
def step_targeted_card_placed_on_stack(game_state):
    """Rule 1.8.5: Card is placed on the stack."""
    # Engine Feature Needed: CardLayer requiring target declaration on stack placement
    game_state.play_card_to_stack(game_state.targeted_damage_card)
    game_state.target_required = game_state.check_target_required_on_stack(
        game_state.targeted_damage_card
    )


@then("a target must be declared for the targeted effect")
def step_target_must_be_declared(game_state):
    """Rule 1.8.5: Target declaration is required at stack placement."""
    # Engine Feature Needed: TargetedEffect.requires_declaration_at_play = True
    assert game_state.target_required is True


# ---------------------------------------------------------------------------
# Scenario: only public objects in arena or on stack are legal targets
# Tests Rule 1.8.5a - Only public objects in arena or stack are targetable
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "only public objects in arena or on stack are legal targets",
)
def test_only_public_arena_stack_objects_are_legal_targets():
    """Rule 1.8.5a: Only public objects in arena or on stack are legal targets."""
    pass


@given(
    'a player has a card "Frosting" with a targeted effect "deal 3 arcane damage to any target"'
)
def step_frosting_targeted_effect(game_state):
    """Rule 1.8.5a: Frosting targets any object."""
    game_state.frosting = game_state.create_card(name="Frosting")
    game_state.frosting.functional_text = "Deal 3 arcane damage to any target."


@given("a hero is in the arena as a public object")
def step_hero_in_arena_public(game_state):
    """Rule 1.8.5a: Hero is in the arena and public."""
    game_state.arena_hero = game_state.create_card(
        name="Arena Hero", card_type=CardType.HERO
    )
    game_state.play_card_to_arena(game_state.arena_hero, controller_id=1)
    game_state.arena_hero._is_public = True


@given("a card is face-down in the player's hand")
def step_card_face_down_in_hand(game_state):
    """Rule 1.8.5a: Card in hand is private/face-down."""
    game_state.hand_card = game_state.create_card(name="Hand Card")
    game_state.player.hand.add_card(game_state.hand_card)
    game_state.hand_card._is_public = False


@when("determining legal targets for Frosting")
def step_determine_legal_targets(game_state):
    """Rule 1.8.5a: Determine which objects are legal targets."""
    # Engine Feature Needed: TargetedEffect.get_legal_targets() filtering arena/stack public objects
    game_state.arena_hero_is_legal = game_state.check_is_legal_target(
        game_state.arena_hero
    )
    game_state.hand_card_is_legal = game_state.check_is_legal_target(
        game_state.hand_card
    )


@then("the hero in the arena should be a legal target")
def step_arena_hero_is_legal_target(game_state):
    """Rule 1.8.5a: Public arena object is a legal target."""
    # Engine Feature Needed: TargetingSystem checking public + arena/stack location
    assert game_state.arena_hero_is_legal is True


@then("the face-down card in hand should not be a legal target")
def step_hand_card_not_legal_target(game_state):
    """Rule 1.8.5a: Private hand object is not a legal target."""
    # Engine Feature Needed: TargetingSystem rejecting private/hand objects
    assert game_state.hand_card_is_legal is False


# ---------------------------------------------------------------------------
# Scenario: effect specifying a zone can target public objects in that zone
# Tests Rule 1.8.5a - Effect specifying zone targets that zone's objects
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect specifying a zone can target public objects in that zone",
)
def test_effect_specifying_zone_can_target_that_zone():
    """Rule 1.8.5a: Effect specifying a zone can target public objects in that zone."""
    pass


@given(
    'a player has a card "Memorial Ground" with an effect targeting a card in the graveyard'
)
def step_memorial_ground_graveyard_target(game_state):
    """Rule 1.8.5a: Memorial Ground targets from graveyard (public zone)."""
    game_state.memorial_ground = game_state.create_card(name="Memorial Ground")
    game_state.memorial_ground.functional_text = "Put target attack action card with cost 2 or less from your graveyard on top of your deck."
    game_state.memorial_ground._targets_graveyard = True


@given("a face-up attack card with cost 2 is in the graveyard")
def step_face_up_attack_in_graveyard(game_state):
    """Rule 1.8.5a: Public face-up card in graveyard is a legal target."""
    game_state.graveyard_attack_card = game_state.create_card(
        name="Attack Card", cost=2
    )
    game_state.graveyard_attack_card._is_public = True
    game_state.graveyard_attack_card._is_in_graveyard = True


@given("a face-down card is also in the graveyard")
def step_face_down_in_graveyard(game_state):
    """Rule 1.8.5a: Private face-down card in graveyard is not a legal target."""
    game_state.graveyard_face_down = game_state.create_card(name="Face Down Card")
    game_state.graveyard_face_down._is_public = False
    game_state.graveyard_face_down._is_in_graveyard = True


@when("determining legal targets for Memorial Ground")
def step_determine_graveyard_legal_targets(game_state):
    """Rule 1.8.5a: Determine legal targets in graveyard."""
    # Engine Feature Needed: TargetedEffect targeting graveyard (public zone)
    game_state.face_up_is_legal = (
        game_state.graveyard_attack_card._is_public
        and game_state.graveyard_attack_card._is_in_graveyard
    )
    game_state.face_down_is_legal = (
        game_state.graveyard_face_down._is_public
        and game_state.graveyard_face_down._is_in_graveyard
    )


@then("the face-up attack card should be a legal target")
def step_face_up_graveyard_card_is_legal(game_state):
    """Rule 1.8.5a: Public card in public zone is legal target."""
    # Engine Feature Needed: TargetingSystem allowing public cards in specified zones
    assert game_state.face_up_is_legal is True


@then("the face-down card should not be a legal target")
def step_face_down_graveyard_card_not_legal(game_state):
    """Rule 1.8.5a: Private card in zone is not a legal target."""
    # Engine Feature Needed: TargetingSystem rejecting face-down cards
    assert game_state.face_down_is_legal is False


# ---------------------------------------------------------------------------
# Scenario: same target cannot be declared more than once for one instance
# Tests Rule 1.8.5b - Same target cannot be declared twice
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "same target cannot be declared more than once for one instance",
)
def test_same_target_cannot_be_declared_twice():
    """Rule 1.8.5b: The same legal target cannot be declared more than once for one instance."""
    pass


@given("a player has an effect requiring 2 targets")
def step_effect_requiring_two_targets(game_state):
    """Rule 1.8.5b: Effect requires two distinct targets."""
    game_state.two_target_effect_card = game_state.create_card(name="Two Target Card")
    game_state.hero_target = game_state.create_card(
        name="Target Hero", card_type=CardType.HERO
    )


@given("the player selects the same target twice")
def step_player_selects_same_target_twice(game_state):
    """Rule 1.8.5b: Player attempts to declare same target twice."""
    game_state.declared_targets = [game_state.hero_target, game_state.hero_target]


@when("validating the target declaration")
def step_validate_duplicate_targets(game_state):
    """Rule 1.8.5b: Validate target declaration for duplicates."""
    # Engine Feature Needed: TargetedEffect.validate_target_declaration() rejecting duplicates
    unique_targets = set(id(t) for t in game_state.declared_targets)
    required_targets = 2
    game_state.target_declaration_valid = len(unique_targets) >= required_targets


@then("the target declaration should be invalid")
def step_target_declaration_invalid(game_state):
    """Rule 1.8.5b: Duplicate target declaration is invalid."""
    # Engine Feature Needed: TargetedEffect rejecting duplicate targets
    assert game_state.target_declaration_valid is False


# ---------------------------------------------------------------------------
# Scenario: non-target effect subjects do not need to be declared at stack placement
# Tests Rule 1.8.5c - Non-targeted effect subjects not declared at stack placement
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "non-target effect subjects do not need to be declared at stack placement",
)
def test_non_target_effect_subjects_not_declared_at_stack():
    """Rule 1.8.5c: Non-targeted effects do not require subject declaration at stack placement."""
    pass


@given(
    'a player has a card "Remembrance" with an effect "shuffle up to 3 action cards from your graveyard"'
)
def step_remembrance_non_target_effect(game_state):
    """Rule 1.8.5c: Remembrance does not use 'target' keyword."""
    game_state.remembrance = game_state.create_card(name="Remembrance")
    game_state.remembrance.functional_text = (
        "Shuffle up to 3 action cards from your graveyard into your deck."
    )
    game_state.remembrance._is_targeted_effect = False  # No "target" keyword


@when("the non-targeted card is placed onto the stack")
def step_remembrance_placed_on_stack(game_state):
    """Rule 1.8.5c: Remembrance placed on stack without target declaration."""
    game_state.play_card_to_stack(game_state.remembrance)
    game_state.required_target_at_play = game_state.check_target_required_on_stack(
        game_state.remembrance
    )


@then("no target declaration is required at this time")
def step_no_target_required_at_play(game_state):
    """Rule 1.8.5c: Non-targeted effects don't need declaration at play time."""
    # Engine Feature Needed: NonTargetedEffect.requires_declaration_at_play = False
    assert game_state.required_target_at_play is False


@then("subjects are determined when the effect is generated upon resolution")
def step_subjects_determined_at_resolution(game_state):
    """Rule 1.8.5c: Subjects declared when effect is generated on resolution."""
    # Engine Feature Needed: NonTargetedEffect deferring subject selection to resolution
    # This is a behavioral expectation; subjects are chosen at resolution not stack placement
    assert game_state.remembrance._is_targeted_effect is False


# ---------------------------------------------------------------------------
# Scenario: targeted effect restricts legal targets based on effect requirements
# Tests Rule 1.8.5d - Targeted effect restricted by what effect can apply to
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "targeted effect restricts legal targets based on effect requirements",
)
def test_targeted_effect_restricts_based_on_requirements():
    """Rule 1.8.5d: Targeted effect restricts legal targets based on effect requirements."""
    pass


@given(
    'a player has a card "Rewind" with an effect "negate target non-attack action card"'
)
def step_rewind_targeted_effect(game_state):
    """Rule 1.8.5d: Rewind can only negate non-attack action cards."""
    game_state.rewind = game_state.create_card(name="Rewind")
    game_state.rewind.functional_text = (
        "Negate target non-attack action card and return it to its owner's hand."
    )
    game_state.rewind._target_restriction = "non_attack_action_card"


@given("a non-attack action card is on the stack")
def step_non_attack_action_on_stack(game_state):
    """Rule 1.8.5d: Legal target for Rewind."""
    game_state.non_attack_on_stack = game_state.create_card(
        name="Action Card", card_type=CardType.ACTION
    )
    # Remove attack subtype - this is a non-attack action
    game_state.non_attack_on_stack._is_attack = False
    game_state.play_card_to_stack(game_state.non_attack_on_stack)


@given("an attack action card is on the stack")
def step_attack_action_on_stack(game_state):
    """Rule 1.8.5d: Illegal target for Rewind (it's an attack)."""
    game_state.attack_on_stack = game_state.create_card(name="Attack Action")
    game_state.attack_on_stack._is_attack = True
    game_state.play_card_to_stack(game_state.attack_on_stack)


@when("determining legal targets for Rewind")
def step_determine_rewind_legal_targets(game_state):
    """Rule 1.8.5d: Determine which stack cards are legal targets for Rewind."""
    # Engine Feature Needed: TargetedEffect.apply_restrictions() filtering by effect parameters
    game_state.non_attack_is_legal_for_rewind = not getattr(
        game_state.non_attack_on_stack, "_is_attack", False
    )
    game_state.attack_is_legal_for_rewind = not getattr(
        game_state.attack_on_stack, "_is_attack", True
    )


@then("the non-attack action card on stack should be a legal target")
def step_non_attack_legal_for_rewind(game_state):
    """Rule 1.8.5d: Non-attack action card is a legal target for Rewind."""
    # Engine Feature Needed: TargetedEffect.apply_restrictions() allowing non-attack action
    assert game_state.non_attack_is_legal_for_rewind is True


@then("the attack action card should not be a legal target for Rewind")
def step_attack_not_legal_for_rewind(game_state):
    """Rule 1.8.5d: Attack action card is not a legal target for Rewind."""
    # Engine Feature Needed: TargetedEffect.apply_restrictions() rejecting attack cards
    assert game_state.attack_is_legal_for_rewind is False


# ---------------------------------------------------------------------------
# Scenario: optional targeted effect allows choosing no target
# Tests Rule 1.8.5e - Optional targeted effect: player may choose no target
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "optional targeted effect allows choosing no target",
)
def test_optional_targeted_effect_allows_no_target():
    """Rule 1.8.5e: If a targeted effect is optional, the player may choose not to select a target."""
    pass


@given(
    'a player has a card with an optional targeted effect "you may deal 2 damage to target hero"'
)
def step_optional_targeted_damage(game_state):
    """Rule 1.8.5e: Card has optional targeted damage."""
    game_state.optional_target_card = game_state.create_card(
        name="Optional Target Card"
    )
    game_state.optional_target_card.functional_text = (
        "You may deal 2 damage to target hero."
    )
    game_state.optional_target_card._is_optional_targeted = True


@when("the player chooses not to select a target")
def step_player_chooses_no_target(game_state):
    """Rule 1.8.5e: Player declines to select a target."""
    game_state.player_selected_target = None


@then("the optional targeted effect should not be generated")
def step_optional_targeted_not_generated(game_state):
    """Rule 1.8.5e: No target selection means optional effect not generated."""
    # Engine Feature Needed: OptionalTargetedEffect checking if player selected target
    assert game_state.player_selected_target is None


# ---------------------------------------------------------------------------
# Scenario: modifying a target can only select legal targets for the original effect
# Tests Rule 1.8.5f - Target modification only allows legal targets
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "modifying a target can only select legal targets for the original effect",
)
def test_target_modification_only_allows_legal_targets():
    """Rule 1.8.5f: When modifying a target, only legal targets for the original effect are allowed."""
    pass


@given(
    'a player has a card "Taipanis" with an effect to redirect a lethal damage source'
)
def step_taipanis_redirect_effect(game_state):
    """Rule 1.8.5f: Taipanis can redirect targets of lethal damage sources."""
    game_state.taipanis = game_state.create_card(name="Taipanis, Dracai of Judgement")
    game_state.taipanis.functional_text = (
        "The first time each turn another hero becomes the target of a source that would "
        "deal lethal damage, you may discard a red card. If you do, choose new targets for that source."
    )


@given("the lethal damage source only has heroes as legal targets")
def step_damage_source_only_heroes_as_legal_targets(game_state):
    """Rule 1.8.5f: Legal targets are limited to opposing heroes."""
    game_state.opposing_hero = game_state.create_card(
        name="Opposing Hero", card_type=CardType.HERO
    )
    game_state.another_hero = game_state.create_card(
        name="Another Hero", card_type=CardType.HERO
    )
    game_state.own_hero = game_state.create_card(
        name="Own Hero", card_type=CardType.HERO
    )
    game_state.own_hero._is_own_hero = True  # Can't attack own hero


@when("Taipanis attempts to choose new targets")
def step_taipanis_chooses_new_target(game_state):
    """Rule 1.8.5f: Taipanis tries to redirect to another opposing hero."""
    # Engine Feature Needed: TargetedEffect.modify_target() validating legal targets
    game_state.redirect_to_another_hero_valid = not getattr(
        game_state.another_hero, "_is_own_hero", False
    )
    game_state.redirect_to_own_hero_valid = not True  # Own hero cannot be attacked


@then("only heroes should be valid new targets")
def step_only_heroes_as_new_targets(game_state):
    """Rule 1.8.5f: Can only redirect to legal attack targets (opposing heroes)."""
    # Engine Feature Needed: TargetedEffect.modify_target() allowing only original legal targets
    assert game_state.redirect_to_another_hero_valid is True


@then("the same hero's own hero should not be a valid target")
def step_own_hero_not_valid_redirect_target(game_state):
    """Rule 1.8.5f: Cannot redirect attack to own hero (illegal original target)."""
    # Engine Feature Needed: TargetedEffect.modify_target() rejecting own hero
    assert game_state.redirect_to_own_hero_valid is False


# ---------------------------------------------------------------------------
# Scenario: no valid new target leaves original target unchanged
# Tests Rule 1.8.5f - Target remains unmodified if no other legal target
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "no valid new target leaves original target unchanged",
)
def test_no_valid_new_target_leaves_original_unchanged():
    """Rule 1.8.5f: If no other legal target exists, the original target remains."""
    pass


@given("a player has an effect that can modify another effect's target")
def step_target_modifying_effect(game_state):
    """Rule 1.8.5f: Effect can modify other effect's target."""
    game_state.modify_target_effect_card = game_state.create_card(name="Target Changer")


@given("there are no other legal targets for the original targeted effect")
def step_no_other_legal_targets(game_state):
    """Rule 1.8.5f: Only one legal target exists."""
    game_state.only_hero = game_state.create_card(
        name="Only Hero", card_type=CardType.HERO
    )
    game_state.original_target = game_state.only_hero
    game_state.other_legal_targets = []  # No other legal targets


@when("the modifying effect attempts to change the target")
def step_attempt_to_change_target(game_state):
    """Rule 1.8.5f: Try to change target when no other legal targets."""
    # Engine Feature Needed: TargetedEffect.modify_target() leaving target unchanged when no alternatives
    no_alternatives = len(game_state.other_legal_targets) == 0
    game_state.target_after_modification = (
        game_state.original_target if no_alternatives else None
    )


@then("the original target should remain unchanged")
def step_original_target_remains(game_state):
    """Rule 1.8.5f: Target remains the same when no alternatives exist."""
    # Engine Feature Needed: TargetedEffect.modify_target() preserving original when no alternatives
    assert game_state.target_after_modification is game_state.original_target


# ---------------------------------------------------------------------------
# Scenario: player determines undetermined effect parameters at resolution
# Tests Rule 1.8.6 - Undetermined parameters resolved by instructed player
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "player determines undetermined effect parameters at resolution",
)
def test_player_determines_parameters_at_resolution():
    """Rule 1.8.6: If parameters are undetermined, the player determines them when effect generates."""
    pass


@given(
    'a player has a card "Remembrance" with an effect "shuffle up to 3 action cards from graveyard"'
)
def step_remembrance_undetermined_params(game_state):
    """Rule 1.8.6: Remembrance effect parameters are undetermined at stack placement."""
    game_state.remembrance_card = game_state.create_card(name="Remembrance")
    game_state.remembrance_card.functional_text = (
        "Shuffle up to 3 action cards from your graveyard into your deck."
    )
    game_state.remembrance_card._max_param_count = 3


@given("the player has 5 action cards in their graveyard")
def step_player_has_5_graveyard_cards(game_state):
    """Rule 1.8.6: Many choices available for parameter selection."""
    game_state.graveyard_action_cards = []
    for i in range(5):
        card = game_state.create_card(name=f"Graveyard Card {i}")
        game_state.graveyard_action_cards.append(card)
    game_state.available_param_count = len(game_state.graveyard_action_cards)


@when("the card resolves and the effect is generated")
def step_remembrance_resolves(game_state):
    """Rule 1.8.6: Effect generated - player must determine parameters."""
    # Engine Feature Needed: ParameterizedEffect.determine_parameters(player_id)
    game_state.effect_requires_player_param_selection = True
    game_state.max_selectable = min(
        game_state.remembrance_card._max_param_count, game_state.available_param_count
    )


@then("the player must determine which cards are the parameters")
def step_player_determines_params(game_state):
    """Rule 1.8.6: Player selects parameters when effect generates."""
    # Engine Feature Needed: ParameterizedEffect requiring player input
    assert game_state.effect_requires_player_param_selection is True


@then("the player may select up to 3 of those cards")
def step_player_can_select_up_to_3(game_state):
    """Rule 1.8.6: Maximum 3 cards can be selected."""
    # Engine Feature Needed: ParameterizedEffect.max_count = 3
    assert game_state.max_selectable == 3


# ---------------------------------------------------------------------------
# Scenario: effect with no legal parameters fails
# Tests Rule 1.8.6 - No legal parameters causes effect to fail
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect with no legal parameters fails",
)
def test_effect_fails_with_no_legal_parameters():
    """Rule 1.8.6: If no legal parameters exist, the related part of the effect fails."""
    pass


@given("a player has an effect that requires determining a target card")
def step_effect_requires_target_card(game_state):
    """Rule 1.8.6: Effect requires a card as parameter."""
    game_state.param_required_card = game_state.create_card(name="Param Required Card")
    game_state.param_required_card._requires_card_parameter = True


@given("there are no eligible cards in the relevant zone")
def step_no_eligible_cards(game_state):
    """Rule 1.8.6: No legal parameters exist."""
    game_state.eligible_cards = []


@when("the no-parameter effect is generated")
def step_no_params_effect_generated(game_state):
    """Rule 1.8.6: Effect tries to generate but no legal parameters."""
    # Engine Feature Needed: ParameterizedEffect.determine_parameters() failing when none available
    game_state.effect_part_failed = len(game_state.eligible_cards) == 0


@then("the part of the effect related to those parameters should fail")
def step_effect_param_part_fails(game_state):
    """Rule 1.8.6: Effect part fails when no legal parameters."""
    # Engine Feature Needed: ParameterizedEffect.fail() called when no legal parameters
    assert game_state.effect_part_failed is True


# ---------------------------------------------------------------------------
# Scenario: multiple players determine parameters in clockwise order from controller
# Tests Rule 1.8.6a - Multiple players determine parameters clockwise
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "multiple players determine parameters in clockwise order from controller",
)
def test_multiple_players_determine_params_clockwise():
    """Rule 1.8.6a: Multiple players determine parameters clockwise from controller."""
    pass


@given(
    'a card "Codex of Frailty" has an effect requiring all heroes to choose a card from their graveyard'
)
def step_codex_of_frailty_all_choose(game_state):
    """Rule 1.8.6a: Each player must determine parameters."""
    game_state.codex_card = game_state.create_card(name="Codex of Frailty")
    game_state.codex_card.functional_text = "Each hero puts an attack action card from their graveyard face-down into their arsenal."
    game_state.codex_card._requires_all_players_to_determine_params = True


@given("player 0 controls the effect")
def step_player_0_controls_codex_effect(game_state):
    """Rule 1.8.6a: Player 0 is the controller - starts first."""
    game_state.effect_controller_id = 0
    game_state.num_players = 2


@when("the parameters are being determined")
def step_parameters_being_determined(game_state):
    """Rule 1.8.6a: Players determine params in clockwise order."""
    # Engine Feature Needed: ParameterizedEffect.determine_parameters_clockwise(controller_id)
    game_state.determination_order = list(
        range(
            game_state.effect_controller_id,
            game_state.effect_controller_id + game_state.num_players,
        )
    )
    # Modulo for wrap-around
    game_state.determination_order = [
        p % game_state.num_players for p in game_state.determination_order
    ]


@then("player 0 determines their parameter first")
def step_player_0_determines_first(game_state):
    """Rule 1.8.6a: Controller (player 0) goes first."""
    # Engine Feature Needed: ClockwiseOrderSystem starting with controller
    assert game_state.determination_order[0] == 0


@then("the next player clockwise determines their parameter second")
def step_next_player_determines_second(game_state):
    """Rule 1.8.6a: Player 1 (next clockwise) goes second."""
    # Engine Feature Needed: ClockwiseOrderSystem continuing clockwise
    assert game_state.determination_order[1] == 1


# ---------------------------------------------------------------------------
# Scenario: parameter determination can only select public objects in arena or on stack
# Tests Rule 1.8.6b - Parameters must be public objects in arena or stack
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "parameter determination can only select public objects in arena or on stack",
)
def test_parameter_determination_limited_to_public_arena_stack():
    """Rule 1.8.6b: Parameters for determining an object must be public objects in arena or stack."""
    pass


@given('a player has a card "Oasis Respite" with an effect allowing source selection')
def step_oasis_respite_source_selection(game_state):
    """Rule 1.8.6b: Oasis Respite allows selecting any public source."""
    game_state.oasis_respite = game_state.create_card(name="Oasis Respite")
    game_state.oasis_respite.functional_text = "Prevent the next 4 damage that would be dealt to target hero this turn by a source of your choice."


@given("a face-up card is in the arena")
def step_face_up_in_arena(game_state):
    """Rule 1.8.6b: Public arena card is valid parameter."""
    game_state.public_arena_card = game_state.create_card(name="Public Arena Card")
    game_state.public_arena_card._is_public = True
    game_state.play_card_to_arena(game_state.public_arena_card)


@given("a face-down card is also in the arena")
def step_face_down_in_arena(game_state):
    """Rule 1.8.6b: Private arena card is not a valid parameter."""
    game_state.private_arena_card = game_state.create_card(name="Private Arena Card")
    game_state.private_arena_card._is_public = False
    game_state.play_card_to_arena(game_state.private_arena_card)


@when("the player determines the source parameter")
def step_player_determines_source_param(game_state):
    """Rule 1.8.6b: Player determines which card is the source."""
    # Engine Feature Needed: ParameterizedEffect.get_legal_parameter_objects() public only
    game_state.public_card_is_valid_param = game_state.public_arena_card._is_public
    game_state.private_card_is_valid_param = game_state.private_arena_card._is_public


@then("the face-up card should be a valid parameter choice")
def step_face_up_valid_param(game_state):
    """Rule 1.8.6b: Public card is valid parameter."""
    # Engine Feature Needed: ParameterizedEffect accepting public objects
    assert game_state.public_card_is_valid_param is True


@then("the face-down card should not be a valid parameter choice")
def step_face_down_not_valid_param(game_state):
    """Rule 1.8.6b: Private card is not valid parameter."""
    # Engine Feature Needed: ParameterizedEffect rejecting private objects
    assert game_state.private_card_is_valid_param is False


# ---------------------------------------------------------------------------
# Scenario: insufficient legal objects means all legal objects become parameters
# Tests Rule 1.8.6c - All legal objects used as parameters when insufficient
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "insufficient legal objects means all legal objects become parameters",
)
def test_insufficient_objects_uses_all_available():
    """Rule 1.8.6c: If insufficient legal objects, all legal objects are used as parameters."""
    pass


@given(
    'a card "System Reset" has an effect "banish X items you control" with X equal to 4'
)
def step_system_reset_insufficient_items(game_state):
    """Rule 1.8.6c: System Reset needs 4 items but player has fewer."""
    game_state.system_reset = game_state.create_card(name="System Reset")
    game_state.system_reset.functional_text = (
        "Banish X Mechanologist items you control."
    )
    game_state.banish_count_x = 4


@given("the player only controls 2 items")
def step_player_controls_2_items(game_state):
    """Rule 1.8.6c: Only 2 items available (fewer than X=4)."""
    game_state.controlled_items = []
    for i in range(2):
        item = game_state.create_card(name=f"Item {i}")
        item._is_item = True
        game_state.controlled_items.append(item)


@when("the system reset effect is generated")
def step_system_reset_generates(game_state):
    """Rule 1.8.6c: Effect generates with fewer items than X."""
    # Engine Feature Needed: ParameterizedEffect.use_all_available_if_insufficient
    available = len(game_state.controlled_items)
    game_state.actual_banish_targets = game_state.controlled_items[
        : min(game_state.banish_count_x, available)
    ]


@then("all 2 items should become the parameters for the banish effect")
def step_all_available_items_are_params(game_state):
    """Rule 1.8.6c: All 2 available items become parameters when fewer than X."""
    # Engine Feature Needed: ParameterizedEffect using all available when insufficient
    assert len(game_state.actual_banish_targets) == 2


# ---------------------------------------------------------------------------
# Scenario: player determines order of compound event individual events
# Tests Rule 1.8.6d - Player determines order of compound events
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "player determines order of compound event individual events",
)
def test_player_determines_compound_event_order():
    """Rule 1.8.6d: If an effect generates a compound event, the player determines the order."""
    pass


@given(
    "a player has an effect that generates a compound event banishing multiple cards"
)
def step_compound_event_effect(game_state):
    """Rule 1.8.6d: Effect banishes multiple cards as a compound event."""
    game_state.compound_effect_card = game_state.create_card(
        name="Tome of Imperial Flame"
    )
    game_state.compound_effect_card.functional_text = "… banish your hand."


@given("the player has 3 cards to banish")
def step_player_has_3_cards_to_banish(game_state):
    """Rule 1.8.6d: Three cards will be banished."""
    game_state.cards_to_banish = []
    for i in range(3):
        card = game_state.create_card(name=f"Hand Card {i}")
        game_state.player.hand.add_card(card)
        game_state.cards_to_banish.append(card)


@when("the player determines the order of banishing")
def step_player_determines_banish_order(game_state):
    """Rule 1.8.6d: Player declares the order of the compound event."""
    # Engine Feature Needed: CompoundEvent.determine_order(player_id)
    game_state.declared_banish_order = [
        game_state.cards_to_banish[2],  # Player chooses this order
        game_state.cards_to_banish[0],
        game_state.cards_to_banish[1],
    ]


@then("the player specifies which card is banished first")
def step_player_specifies_first_banish(game_state):
    """Rule 1.8.6d: Player specifies order for first card."""
    # Engine Feature Needed: CompoundEvent storing player-determined order
    assert game_state.declared_banish_order[0] is game_state.cards_to_banish[2]


@then("the player specifies which card is banished second")
def step_player_specifies_second_banish(game_state):
    """Rule 1.8.6d: Player specifies order for second card."""
    # Engine Feature Needed: CompoundEvent with ordered event list
    assert game_state.declared_banish_order[1] is game_state.cards_to_banish[0]


@then("the player specifies which card is banished third")
def step_player_specifies_third_banish(game_state):
    """Rule 1.8.6d: Player specifies order for third card."""
    # Engine Feature Needed: CompoundEvent with ordered event list
    assert game_state.declared_banish_order[2] is game_state.cards_to_banish[1]


# ---------------------------------------------------------------------------
# Scenario: effect condition requiring property value fails for objects without that property
# Tests Rule 1.8.7 - Effect condition infers property existence
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect condition requiring property value fails for objects without that property",
)
def test_effect_condition_fails_for_objects_without_property():
    """Rule 1.8.7: Effect condition referring to property value fails for objects without that property."""
    pass


@given(
    'a card "Harmonized Kodachi" has a condition "if you have a card in pitch zone with cost 0"'
)
def step_harmonized_kodachi_condition(game_state):
    """Rule 1.8.7: Condition requires cost property to exist and be 0."""
    game_state.harmonized_kodachi = game_state.create_card(name="Harmonized Kodachi")
    game_state.harmonized_kodachi.functional_text = (
        "If you have a card in your pitch zone with cost 0,"
    )


@given('a card "Heart of Fyendal" with no cost property is in the pitch zone')
def step_heart_of_fyendal_in_pitch(game_state):
    """Rule 1.8.7: Card without cost property is in pitch zone."""
    game_state.heart_of_fyendal = game_state.create_card(name="Heart of Fyendal")
    # Mark as not having cost property via instance metadata (CardTemplate is frozen)
    game_state.heart_of_fyendal._has_no_cost_property = True
    game_state.player.pitch_zone.add_card(game_state.heart_of_fyendal)


@when("evaluating the condition")
def step_evaluate_cost_condition(game_state):
    """Rule 1.8.7: Evaluate if any card in pitch zone has cost 0."""
    # Engine Feature Needed: PropertyExistenceCheck - object without property doesn't meet condition
    card_in_pitch = game_state.heart_of_fyendal
    # Check if card has been marked as lacking the cost property
    lacks_cost_property = getattr(card_in_pitch, "_has_no_cost_property", False)
    has_cost_property = not lacks_cost_property and card_in_pitch.template.has_cost
    game_state.heart_satisfies_condition = (
        has_cost_property and card_in_pitch.template.cost == 0
    )


@then('Heart of Fyendal should not satisfy the "cost 0" condition')
def step_heart_does_not_satisfy_condition(game_state):
    """Rule 1.8.7: Card without cost property does not meet cost-based condition."""
    # Engine Feature Needed: Effect condition checking property existence first
    assert game_state.heart_satisfies_condition is False


# ---------------------------------------------------------------------------
# Scenario: cards without cost property are not restricted by cost-based effects
# Tests Rule 1.8.7 - Objects without property not affected by property-based restrictions
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "cards without cost property are not restricted by cost-based effects",
)
def test_cards_without_cost_property_not_restricted_by_cost_effects():
    """Rule 1.8.7: Cards without cost property are not restricted by cost-based effects."""
    pass


@given(
    'a card "Find Center" has an effect that restricts defending with cards of cost less than X'
)
def step_find_center_cost_restriction(game_state):
    """Rule 1.8.7: Find Center restricts defenders with cost less than chain links."""
    game_state.find_center = game_state.create_card(name="Find Center")
    game_state.find_center.functional_text = "… this can't be defended by cards with cost less than the number of chain links you control."
    game_state.chain_links_count = 3  # Restrict cards with cost < 3


@given('a card "Ironrot Helm" with no cost property is available to defend')
def step_ironrot_helm_no_cost(game_state):
    """Rule 1.8.7: Ironrot Helm has no cost property."""
    game_state.ironrot_helm = game_state.create_card(
        name="Ironrot Helm", card_type=CardType.EQUIPMENT
    )
    # Mark via instance metadata (CardTemplate is frozen, can't set directly)
    game_state.ironrot_helm._has_no_cost_property = True


@when("checking if Ironrot Helm can defend Find Center")
def step_check_ironrot_can_defend(game_state):
    """Rule 1.8.7: Evaluate if Ironrot Helm meets Find Center's defender restriction."""
    # Engine Feature Needed: PropertyExistenceCheck - no cost means restriction doesn't apply
    lacks_cost_property = getattr(
        game_state.ironrot_helm, "_has_no_cost_property", False
    )
    ironrot_has_cost = (
        not lacks_cost_property and game_state.ironrot_helm.template.has_cost
    )
    # Find Center restricts cards WITH cost property less than X
    # If card has no cost property, restriction doesn't apply
    game_state.ironrot_can_defend = not ironrot_has_cost  # No cost = can defend


@then("Ironrot Helm should be able to defend because it has no cost property")
def step_ironrot_can_defend(game_state):
    """Rule 1.8.7: Card without cost property is not restricted by cost-based effects."""
    # Engine Feature Needed: Effect condition requiring property existence
    assert game_state.ironrot_can_defend is True


# ---------------------------------------------------------------------------
# Scenario: missing numeric property treated as zero in numeric effects
# Tests Rule 1.8.7a - Missing numeric property uses zero as value
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "missing numeric property treated as zero in numeric effects",
)
def test_missing_numeric_property_treated_as_zero():
    """Rule 1.8.7a: If a numeric property is missing, zero is used as the value."""
    pass


@given(
    'a card "Ravenous Rabble" has an effect "this gets -X power where X is the pitch value of a revealed card"'
)
def step_ravenous_rabble_pitch_effect(game_state):
    """Rule 1.8.7a: X depends on pitch value of revealed card."""
    game_state.ravenous_rabble = game_state.create_card(name="Ravenous Rabble")
    game_state.ravenous_rabble.functional_text = "… reveal the top card of your deck. this gets -X{p}, where X is the pitch value of the card revealed this way."


@given('the revealed card "Gorganian Tome" has no pitch property')
def step_gorganian_tome_no_pitch(game_state):
    """Rule 1.8.7a: Revealed card has no pitch property."""
    game_state.gorganian_tome = game_state.create_card(name="Gorganian Tome")
    game_state.gorganian_tome._has_no_pitch_property = True


@when("calculating X for the effect")
def step_calculate_x_for_effect(game_state):
    """Rule 1.8.7a: Calculate X using pitch value (or 0 if no pitch)."""
    # Engine Feature Needed: Effect.use_zero_for_missing_numeric_property = True
    no_pitch = getattr(game_state.gorganian_tome, "_has_no_pitch_property", False)
    has_pitch = not no_pitch
    if has_pitch:
        game_state.calculated_x = game_state.gorganian_tome.template.pitch
    else:
        game_state.calculated_x = (
            0  # Rule 1.8.7a: use zero for missing numeric property
        )


@then("X should be zero because the card has no pitch property")
def step_x_is_zero(game_state):
    """Rule 1.8.7a: Missing pitch property means X = 0."""
    # Engine Feature Needed: Effect using zero for missing numeric properties
    assert game_state.calculated_x == 0


@then("the power modifier should be 0")
def step_power_modifier_is_zero(game_state):
    """Rule 1.8.7a: -X power means -0 = no change when X is 0."""
    # Engine Feature Needed: Power modifier correctly calculated as 0
    power_modifier = -game_state.calculated_x
    assert power_modifier == 0


# ---------------------------------------------------------------------------
# Scenario: as though effect modifies rules only for that applicable effect
# Tests Rule 1.8.8 - "As though" effect applies only for applicable effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "as though effect modifies rules only for that applicable effect",
)
def test_as_though_effect_applies_only_for_applicable_effect():
    """Rule 1.8.8: 'As though' effect modifies rules only for the applicable effect."""
    pass


@given('a card "Teklovossen" has an effect "this counts as having 4 Evos equipped"')
def step_teklovossen_counts_as_evos(game_state):
    """Rule 1.8.8: Teklovossen counts as having 4 Evos equipped."""
    game_state.teklovossen = game_state.create_card(
        name="Teklovossen, the Mechropotent"
    )
    game_state.teklovossen.functional_text = "This counts as having 4 Evos equipped."
    game_state.teklovossen._virtual_evo_count = 4
    game_state.actual_evos_equipped = 0  # No actual Evos


@when("an effect counts the number of Evos equipped")
def step_effect_counts_evos(game_state):
    """Rule 1.8.8: Counting effect uses the modified count."""
    # Engine Feature Needed: CountsAsEffect providing modified count for applicable effects
    game_state.evo_count_for_counting_effect = (
        game_state.actual_evos_equipped + game_state.teklovossen._virtual_evo_count
    )


@then("the count should include the 4 virtual Evos from the Teklovossen effect")
def step_count_includes_virtual_evos(game_state):
    """Rule 1.8.8: Counting effect sees the virtual 4 Evos."""
    # Engine Feature Needed: CountsAsEffect modifying count for applicable effect
    assert game_state.evo_count_for_counting_effect == 4


@then(
    "effects interacting directly with equipped Evos should not be affected by the virtual count"
)
def step_direct_evo_interactions_unaffected(game_state):
    """Rule 1.8.8: Counts-as effect applies only for counting, not direct interactions."""
    # Engine Feature Needed: CountsAsEffect scoped to only the applicable effect
    # Direct Evo interactions still see actual_evos_equipped (0), not the virtual count
    game_state.evo_count_for_direct_interaction = game_state.actual_evos_equipped
    assert game_state.evo_count_for_direct_interaction == 0


# ---------------------------------------------------------------------------
# Scenario: counts as effect applies only for the applicable effect
# Tests Rule 1.8.8 - "Counts as" effect applies only for that applicable effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "counts as effect applies only for the applicable effect",
)
def test_counts_as_effect_applies_only_for_applicable_effect():
    """Rule 1.8.8: 'Counts as' effect applies only for the applicable effect."""
    pass


@given('a card with an effect "this counts as a weapon attack"')
def step_card_counts_as_weapon_attack(game_state):
    """Rule 1.8.8: Card counts as a weapon attack for applicable effects."""
    game_state.counts_as_weapon = game_state.create_card(name="Counts As Weapon Card")
    game_state.counts_as_weapon._counts_as_weapon_attack = True


@given("an effect that provides a bonus when attacking with a weapon")
def step_weapon_bonus_effect(game_state):
    """Rule 1.8.8: Bonus effect triggered by weapon attacks."""
    game_state.weapon_bonus_active = True
    game_state.weapon_bonus_value = 2


@when("the weapon-counting effect is evaluated")
def step_evaluate_weapon_counting(game_state):
    """Rule 1.8.8: Check if counts-as-weapon gives the weapon attack bonus."""
    # Engine Feature Needed: CountsAsEffect applying to weapon-bonus check
    game_state.bonus_applies = (
        getattr(game_state.counts_as_weapon, "_counts_as_weapon_attack", False)
        and game_state.weapon_bonus_active
    )


@then(
    "the bonus should apply because the card counts as a weapon attack for that effect"
)
def step_bonus_applies_via_counts_as(game_state):
    """Rule 1.8.8: Counts-as effect makes weapon bonus applicable."""
    # Engine Feature Needed: CountsAsEffect triggering weapon-bonus for applicable effect
    assert game_state.bonus_applies is True


@then("other effects unrelated to weapon attacks should not be affected")
def step_unrelated_effects_not_affected(game_state):
    """Rule 1.8.8: Counts-as applies only for the weapon-attack-counting effect."""
    # Engine Feature Needed: CountsAsEffect scoped to applicable effects only
    # The card is not an actual weapon - this is just a test for scoping
    game_state.card_is_actual_weapon = (
        CardType.WEAPON in game_state.counts_as_weapon.template.types
    )
    assert game_state.card_is_actual_weapon is False


# ---------------------------------------------------------------------------
# Scenario: effect fails when its target ceases to exist before resolution
# Tests Rule 1.8.9 - Effect fails when target ceases to exist
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect fails when its target ceases to exist before resolution",
)
def test_effect_fails_when_target_ceases_to_exist():
    """Rule 1.8.9: An effect fails if its target(s) cease to exist."""
    pass


@given("a player has a targeted effect on the stack targeting a hero")
def step_targeted_effect_on_stack(game_state):
    """Rule 1.8.9: Targeted effect on stack targeting a specific hero."""
    game_state.target_for_effect = game_state.create_card(
        name="Target Hero", card_type=CardType.HERO
    )
    game_state.targeted_effect = game_state.create_damage_effect(
        source=game_state.create_card(name="Effect Source"),
        damage_amount=3,
        target=game_state.target_for_effect,
    )


@given("the target hero ceases to exist before the effect resolves")
def step_target_ceases_to_exist(game_state):
    """Rule 1.8.9: Target is destroyed/removed before effect resolves."""
    game_state.target_for_effect._is_in_game = False  # Target has ceased to exist


@when("the targeted effect attempts to resolve")
def step_effect_attempts_to_resolve(game_state):
    """Rule 1.8.9: Effect tries to resolve with missing target."""
    # Engine Feature Needed: Effect.fail() when target not in game
    target_exists = getattr(game_state.target_for_effect, "_is_in_game", True)
    game_state.effect_resolution_result = game_state.resolve_targeted_effect(
        game_state.targeted_effect, target_exists=target_exists
    )


@then("the targeted effect should fail")
def step_effect_fails_due_to_missing_target(game_state):
    """Rule 1.8.9: Effect fails because target ceased to exist."""
    # Engine Feature Needed: Effect.fail() returning failed result when target gone
    assert game_state.effect_resolution_result.failed is True


# ---------------------------------------------------------------------------
# Scenario: effect does not fail if at least one event succeeds
# Tests Rule 1.8.9 - Effect does not fail if at least one event succeeds
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect does not fail if at least one event succeeds",
)
def test_effect_does_not_fail_if_one_event_succeeds():
    """Rule 1.8.9: Effect does not fail if at least one of its events succeeds."""
    pass


@given("a player has a multi-part effect targeting two heroes")
def step_multi_part_effect_two_heroes(game_state):
    """Rule 1.8.9: Effect targets two heroes."""
    game_state.hero_1 = game_state.create_card(name="Hero 1", card_type=CardType.HERO)
    game_state.hero_2 = game_state.create_card(name="Hero 2", card_type=CardType.HERO)
    game_state.multi_effect = game_state.create_multi_target_damage_effect(
        targets=[game_state.hero_1, game_state.hero_2],
        damage_amount=3,
    )


@given("one target hero ceases to exist before resolution")
def step_one_hero_ceases(game_state):
    """Rule 1.8.9: Hero 1 is destroyed before resolution."""
    game_state.hero_1._is_in_game = False  # Hero 1 gone


@given("the other target hero still exists")
def step_other_hero_exists(game_state):
    """Rule 1.8.9: Hero 2 still exists."""
    game_state.hero_2._is_in_game = True  # Hero 2 still alive


@when("the effect resolves")
def step_multi_effect_resolves(game_state):
    """Rule 1.8.9: Multi-part effect resolves."""
    # Engine Feature Needed: Effect.partial_success tracking
    hero_1_succeeds = getattr(game_state.hero_1, "_is_in_game", True)
    hero_2_succeeds = getattr(game_state.hero_2, "_is_in_game", True)
    game_state.at_least_one_success = hero_1_succeeds or hero_2_succeeds
    game_state.effect_failed_overall = not game_state.at_least_one_success


@then("the effect should not fail overall")
def step_multi_effect_does_not_fail(game_state):
    """Rule 1.8.9: Effect doesn't fail if at least one event succeeds."""
    # Engine Feature Needed: Effect.partial_success = True when some events succeed
    assert game_state.effect_failed_overall is False


@then("the damage should be dealt to the surviving hero")
def step_damage_dealt_to_surviving_hero(game_state):
    """Rule 1.8.9: Surviving hero still takes damage."""
    # Engine Feature Needed: Effect applying to available targets only
    assert game_state.hero_2._is_in_game is True


# ---------------------------------------------------------------------------
# Scenario: effect fails when there are no legal parameters at generation time
# Tests Rule 1.8.9 - Effect fails with no legal parameters
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "effect fails when there are no legal parameters at generation time",
)
def test_effect_fails_no_legal_params_at_generation():
    """Rule 1.8.9: An effect fails if there are no legal parameters at the time it is generated."""
    pass


@given("a player has an effect requiring a legal target in the arena")
def step_effect_requiring_arena_target(game_state):
    """Rule 1.8.9: Effect needs a legal arena target."""
    game_state.arena_target_effect = game_state.create_damage_effect(
        source=game_state.create_card(name="Effect Source"),
        damage_amount=3,
        requires_arena_target=True,
    )


@given("there are no legal targets currently in the arena")
def step_no_legal_targets_in_arena(game_state):
    """Rule 1.8.9: Arena is empty - no legal targets."""
    game_state.legal_arena_targets = []


@when("the no-target-arena effect is generated")
def step_no_target_effect_generated(game_state):
    """Rule 1.8.9: Effect tries to generate with no legal parameters."""
    # Engine Feature Needed: Effect.fail() when no legal parameters at generation time
    no_legal_params = len(game_state.legal_arena_targets) == 0
    game_state.no_legal_params_effect_failed = no_legal_params


@then("the no-legal-parameter effect should fail")
def step_no_legal_params_effect_fails(game_state):
    """Rule 1.8.9: Effect fails due to no legal parameters."""
    # Engine Feature Needed: Effect failing when no legal parameters at generation
    assert game_state.no_legal_params_effect_failed is True


# ---------------------------------------------------------------------------
# Scenario: your next attack effect applies to the next attack that comes under control
# Tests Rule 1.8.10 - "Your next attack" refers to next attack under control
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "your next attack effect applies to the next attack that comes under control",
)
def test_next_attack_effect_applies_to_next_attack():
    """Rule 1.8.10: 'Your next attack' refers to the next attack that comes under the player's control."""
    pass


@given('a player has an effect "your next red attack this turn gets +1 power"')
def step_next_red_attack_effect(game_state):
    """Rule 1.8.10: Effect applies to next red attack."""
    game_state.next_red_attack_bonus = 1
    game_state.bonus_applied_to_next_red = False
    game_state.next_attack_effect_active = True


@when("the player plays a red attack card")
def step_player_plays_red_attack(game_state):
    """Rule 1.8.10: Player plays a red attack - this should get the bonus."""
    game_state.played_red_attack = game_state.create_card(
        name="Red Attack", color=Color.RED, card_type=CardType.ACTION
    )
    # Engine Feature Needed: NextAttackEffect tracking and applying to next attack
    if (
        game_state.next_attack_effect_active
        and game_state.played_red_attack.template.color == Color.RED
    ):
        game_state.bonus_applied_to_next_red = True
        game_state.next_attack_effect_active = False  # Consumed


@then("the +1 power bonus should apply to that red attack")
def step_plus_1_bonus_applied(game_state):
    """Rule 1.8.10: The +1 power bonus applies to the red attack."""
    # Engine Feature Needed: NextAttackEffect consuming when next matching attack comes under control
    assert game_state.bonus_applied_to_next_red is True


# ---------------------------------------------------------------------------
# Scenario: attack replaced by stealth still triggers next attack effect
# Tests Rule 1.8.10 - "Your next attack" applies to any method of gaining control
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "attack replaced by stealth still triggers next attack effect",
)
def test_replaced_attack_triggers_next_attack_effect():
    """Rule 1.8.10: 'Your next attack' includes attacks coming under control via stealth replacement."""
    pass


@given(
    'a player has an effect "your next red attack gets +1 power, your next blue gets +3 power"'
)
def step_next_attack_color_bonuses(game_state):
    """Rule 1.8.10: Different bonuses for red and blue attacks."""
    game_state.next_red_bonus = 1
    game_state.next_blue_bonus = 3
    game_state.next_red_effect_active = True
    game_state.next_blue_effect_active = True


@given("the player plays a red attack with stealth")
def step_player_plays_red_stealth_attack(game_state):
    """Rule 1.8.10: Red attack plays, consuming the red bonus."""
    game_state.red_stealth_attack = game_state.create_card(
        name="Red Stealth Attack", color=Color.RED
    )
    # Red attack came under control, consuming next-red-attack effect
    if game_state.next_red_effect_active:
        game_state.red_attack_got_bonus = True
        game_state.next_red_effect_active = False


@given("the red attack is replaced with a blue attack via Uzuri's activated ability")
def step_red_replaced_with_blue(game_state):
    """Rule 1.8.10: Stealth replaces red with blue - new attack comes under control."""
    game_state.blue_replacement_attack = game_state.create_card(
        name="Blue Replacement Attack", color=Color.BLUE
    )
    game_state.blue_replacement_attack._came_under_control_fresh = True


@when("evaluating which bonus applies")
def step_evaluate_which_bonus_applies(game_state):
    """Rule 1.8.10: Determine bonus for the blue replacement attack."""
    # Engine Feature Needed: NextAttackEffect applying to blue attack as new attack under control
    if (
        game_state.next_blue_effect_active
        and game_state.blue_replacement_attack.template.color == Color.BLUE
        and getattr(
            game_state.blue_replacement_attack, "_came_under_control_fresh", False
        )
    ):
        game_state.blue_got_bonus = True
        game_state.blue_bonus_amount = game_state.next_blue_bonus
    else:
        game_state.blue_got_bonus = False
        game_state.blue_bonus_amount = 0


@then(
    "the blue attack should get +3 power as it is a new attack under the player's control"
)
def step_blue_attack_gets_plus_3(game_state):
    """Rule 1.8.10: Blue replacement is a new attack getting +3 bonus."""
    # Engine Feature Needed: NextAttackEffect tracking new attacks under control
    assert game_state.blue_got_bonus is True
    assert game_state.blue_bonus_amount == 3


# ---------------------------------------------------------------------------
# Scenario: attack that changes properties after being played does not gain the effect
# Tests Rule 1.8.10a - Already-controlled object doesn't get "next attack" effect
# ---------------------------------------------------------------------------


@scenario(
    "../features/section_1_8_effects.feature",
    "attack that changes properties after being played does not gain the effect",
)
def test_attack_changing_properties_not_next_attack():
    """Rule 1.8.10a: Object already under control that becomes specified attack type doesn't get 'next attack' effect."""
    pass


@given('a player has an effect "your next blue attack gets +3 power"')
def step_next_blue_attack_effect(game_state):
    """Rule 1.8.10a: Effect applies to next blue attack."""
    game_state.next_blue_bonus = 3
    game_state.next_blue_effect_active = True


@given("a player plays a red attack with stealth")
def step_player_plays_red_for_color_change(game_state):
    """Rule 1.8.10a: Red attack comes under control (already controlled)."""
    game_state.red_attack_under_control = game_state.create_card(
        name="Red Attack Copy Target", color=Color.RED
    )
    game_state.red_attack_under_control._already_under_control = True


@given("Take Up the Mantle changes the red attack to be a copy of a blue card")
def step_take_up_the_mantle_changes_color(game_state):
    """Rule 1.8.10a: Red attack's properties change to blue after already under control."""
    # The attack is already under control - now it becomes blue via copy
    game_state.red_attack_under_control._effective_color = Color.BLUE
    game_state.red_attack_under_control._became_blue_after_control = True


@when("evaluating which bonus applies to the changed attack")
def step_evaluate_bonus_for_changed_attack(game_state):
    """Rule 1.8.10a: Check if the retroactively-blue attack gets the blue bonus."""
    # Engine Feature Needed: NextAttackEffect.does_not_apply_retroactively for property changes
    already_under_control = getattr(
        game_state.red_attack_under_control, "_already_under_control", False
    )
    became_blue_after = getattr(
        game_state.red_attack_under_control, "_became_blue_after_control", False
    )
    is_now_blue = (
        getattr(game_state.red_attack_under_control, "_effective_color", None)
        == Color.BLUE
    )

    # Rule 1.8.10a: Effect does not apply because card was already under control before becoming blue
    game_state.retroactive_blue_gets_bonus = is_now_blue and not (
        already_under_control and became_blue_after
    )


@then("the blue attack copy should not get +3 power")
def step_blue_copy_does_not_get_bonus(game_state):
    """Rule 1.8.10a: Retroactively-blue attack does not get the next-blue-attack bonus."""
    # Engine Feature Needed: NextAttackEffect.does_not_apply_retroactively = True
    assert game_state.retroactive_blue_gets_bonus is False


@then(
    "the reason should be that the attack was already under the player's control before becoming blue"
)
def step_reason_already_under_control(game_state):
    """Rule 1.8.10a: Attack was controlled before becoming the specified type."""
    # Engine Feature Needed: NextAttackEffect tracking whether attack was already controlled
    already_controlled = getattr(
        game_state.red_attack_under_control, "_already_under_control", False
    )
    assert already_controlled is True


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture
def game_state():
    """
    Fixture providing game state for testing Section 1.8 (Effects).

    Uses BDDGameState which integrates with the real engine.
    Reference: Rule 1.8

    Engine Features Needed:
    - [ ] Effect class with source, controller, effect_type attributes (Rule 1.8.1)
    - [ ] Effect.source matches generating ability source (Rule 1.8.1a)
    - [ ] Effect.controller matches generating ability controller (Rule 1.8.1b)
    - [ ] CardInstance.has_effect(effect_type) including optional/conditional (Rule 1.8.2)
    - [ ] OptionalEffect class with requires_player_choice, can_be_generated() (Rule 1.8.3)
    - [ ] OptionalEffect.is_may_choose_to allowing choice regardless (Rule 1.8.3b)
    - [ ] ConditionalEffect evaluating condition at generation time (Rule 1.8.4)
    - [ ] OtherwiseEffect evaluating when preceding fails (Rule 1.8.4a)
    - [ ] UnlessEffect evaluating opposite condition (Rule 1.8.4b)
    - [ ] WhileEffect continuously evaluating condition per subject (Rule 1.8.4c)
    - [ ] TargetedEffect with target declaration at stack placement (Rule 1.8.5)
    - [ ] TargetedEffect.get_legal_targets() with public/arena/stack filtering (Rule 1.8.5a)
    - [ ] TargetedEffect.validate_target_declaration() rejecting duplicates (Rule 1.8.5b)
    - [ ] NonTargetedEffect deferring subject selection (Rule 1.8.5c)
    - [ ] TargetedEffect.apply_restrictions() per effect parameters (Rule 1.8.5d)
    - [ ] TargetedEffect.modify_target() validating legal targets (Rule 1.8.5f)
    - [ ] ParameterizedEffect.determine_parameters() system (Rule 1.8.6)
    - [ ] ParameterizedEffect.determine_parameters_clockwise() (Rule 1.8.6a)
    - [ ] ParameterizedEffect accepting only public objects (Rule 1.8.6b)
    - [ ] ParameterizedEffect.use_all_available_if_insufficient (Rule 1.8.6c)
    - [ ] CompoundEvent.determine_order() (Rule 1.8.6d)
    - [ ] PropertyExistenceCheck for effect conditions (Rule 1.8.7)
    - [ ] Effect.use_zero_for_missing_numeric_property (Rule 1.8.7a)
    - [ ] AsThoughEffect / CountsAsEffect scoped to applicable effect (Rule 1.8.8)
    - [ ] Effect.fail() on missing target (Rule 1.8.9)
    - [ ] Effect.partial_success when some events succeed (Rule 1.8.9)
    - [ ] NextAttackEffect tracking next attack under control (Rule 1.8.10)
    - [ ] NextAttackEffect.does_not_apply_retroactively (Rule 1.8.10a)
    """
    from tests.bdd_helpers import BDDGameState

    state = BDDGameState()

    # Initialize effects-testing specific attributes
    state.target_hero_life = 20
    state.initial_hero_life = 20
    state.damage_effect = None
    state.optional_effect = None
    state.conditional_effect = None

    return state
